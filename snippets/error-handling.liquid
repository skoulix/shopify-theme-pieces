
{%- comment -%}
  Error Handling System
  Provides global error handling, toast notifications, and user-friendly error messages

  Include in theme.liquid: {% render 'error-handling' %}
{%- endcomment -%}

<script>
/**
 * Global Error Handler
 * Provides centralized error handling and user-friendly notifications
 */
window.errorHandler = window.errorHandler || (function() {
  'use strict';

  // Error messages with translations
  const messages = {
    // General errors
    network: `{{ 'errors.network' | t | default: 'Network error. Please check your connection and try again.' }}`,
    server: `{{ 'errors.server' | t | default: 'Something went wrong. Please try again later.' }}`,
    form_submit: `{{ 'errors.form_submit' | t | default: 'Could not submit form. Please try again.' }}`,
    validation: `{{ 'errors.validation' | t | default: 'Please check your input and try again.' }}`,
    unauthorized: `{{ 'errors.unauthorized' | t | default: 'Please log in to continue.' }}`,
    not_found: `{{ 'errors.not_found' | t | default: 'The requested item was not found.' }}`,
    generic: `{{ 'errors.generic' | t | default: 'An error occurred. Please try again.' }}`,
    // Cart errors
    cart_add: `{{ 'cart.errors.add' | t | default: 'Could not add item to cart. Please try again.' }}`,
    cart_update: `{{ 'cart.errors.update' | t | default: 'Could not update cart. Please try again.' }}`,
    cart_remove: `{{ 'cart.errors.remove' | t | default: 'Could not remove item. Please try again.' }}`,
    out_of_stock: `{{ 'cart.errors.out_of_stock' | t | default: 'This item is currently out of stock.' }}`
  };

  /**
   * Show error toast notification
   * @param {string} message - Error message or key
   * @param {Object} options - Additional options
   */
  function showError(message, options = {}) {
    const text = messages[message] || message || messages.generic;
    showToast(text, { type: 'error', ...options });
  }

  /**
   * Show success toast notification
   * @param {string} message - Success message
   * @param {Object} options - Additional options
   */
  function showSuccess(message, options = {}) {
    showToast(message, { type: 'success', ...options });
  }

  /**
   * Show info toast notification
   * @param {string} message - Info message
   * @param {Object} options - Additional options
   */
  function showInfo(message, options = {}) {
    showToast(message, { type: 'info', ...options });
  }

  /**
   * Show warning toast notification
   * @param {string} message - Warning message
   * @param {Object} options - Additional options
   */
  function showWarning(message, options = {}) {
    showToast(message, { type: 'warning', ...options });
  }

  /**
   * Show toast notification
   * @param {string} message - Message to display
   * @param {Object} options - Toast options
   */
  function showToast(message, options = {}) {
    const { type = 'info', duration = type === 'error' ? 5000 : 4000 } = options;

    // Ensure container exists
    let container = document.querySelector('.toast-container');
    if (!container) {
      container = document.createElement('div');
      container.className = 'toast-container';
      container.setAttribute('role', 'status');
      container.setAttribute('aria-live', 'polite');
      document.body.appendChild(container);
    }

    // Create toast
    const toast = document.createElement('div');
    toast.className = `toast toast--${type}`;
    toast.innerHTML = `
      <span class="toast__icon">
        <i class="ph ${getIcon(type)}" aria-hidden="true"></i>
      </span>
      <span class="toast__message">${escapeHtml(message)}</span>
      <button class="toast__close" aria-label="{{ 'accessibility.close' | t | default: 'Dismiss' }}">
        <i class="ph ph-x" aria-hidden="true"></i>
      </button>
    `;

    // Close handler
    const closeBtn = toast.querySelector('.toast__close');
    closeBtn.addEventListener('click', () => dismissToast(toast), { once: true });

    // Add to container
    container.appendChild(toast);

    // Trigger animation
    requestAnimationFrame(() => {
      toast.classList.add('toast--visible');
    });

    // Auto dismiss
    if (duration > 0) {
      setTimeout(() => dismissToast(toast), duration);
    }

    // Announce to screen readers
    if (window.a11y?.announce) {
      window.a11y.announce(message, type === 'error' ? 'assertive' : 'polite');
    }

    return toast;
  }

  /**
   * Dismiss a toast
   */
  function dismissToast(toast) {
    if (!toast || !toast.parentNode) return;

    toast.classList.remove('toast--visible');
    toast.classList.add('toast--leaving');

    setTimeout(() => {
      toast.remove();
    }, 300);
  }

  /**
   * Get icon class for toast type
   */
  function getIcon(type) {
    const icons = {
      success: 'ph-check-circle',
      error: 'ph-warning-circle',
      warning: 'ph-warning',
      info: 'ph-info'
    };
    return icons[type] || icons.info;
  }

  /**
   * Escape HTML to prevent XSS
   */
  function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  /**
   * Handle fetch errors
   * @param {Response} response - Fetch response
   * @returns {Promise} - Resolved or rejected promise
   */
  async function handleFetchError(response) {
    if (response.ok) return response;

    let errorMessage;
    switch (response.status) {
      case 400:
        errorMessage = 'validation';
        break;
      case 401:
        errorMessage = 'unauthorized';
        break;
      case 404:
        errorMessage = 'not_found';
        break;
      case 422:
        // Shopify specific - often inventory issues
        try {
          const data = await response.json();
          if (data.description?.includes('inventory')) {
            errorMessage = 'out_of_stock';
          } else {
            errorMessage = data.description || 'validation';
          }
        } catch {
          errorMessage = 'validation';
        }
        break;
      case 500:
      case 502:
      case 503:
        errorMessage = 'server';
        break;
      default:
        errorMessage = 'generic';
    }

    throw new Error(errorMessage);
  }

  /**
   * Wrap fetch with error handling
   * @param {string} url - URL to fetch
   * @param {Object} options - Fetch options
   * @returns {Promise} - Fetch promise with error handling
   */
  async function safeFetch(url, options = {}) {
    try {
      const response = await fetch(url, options);
      return await handleFetchError(response);
    } catch (error) {
      if (error.name === 'TypeError') {
        // Network error
        throw new Error('network');
      }
      throw error;
    }
  }

  // Global unhandled rejection handler
  window.addEventListener('unhandledrejection', (event) => {
    // Only show toast for non-suppressed errors
    if (event.reason?.showToast !== false) {
      console.error('Unhandled promise rejection:', event.reason);
      // Don't show toast for every unhandled rejection to avoid spam
      // Just log it - specific handlers should show toasts
    }
  });

  // Public API
  return {
    showError,
    showSuccess,
    showInfo,
    showWarning,
    showToast,
    dismissToast,
    handleFetchError,
    safeFetch,
    messages
  };
})();

// Expose globally for easy access
window.toast = {
  error: window.errorHandler.showError,
  success: window.errorHandler.showSuccess,
  info: window.errorHandler.showInfo,
  warning: window.errorHandler.showWarning,
  show: window.errorHandler.showToast
};
</script>
