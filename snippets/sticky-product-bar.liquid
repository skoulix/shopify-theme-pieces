
{%- comment -%}
  Sticky Product Bar
  Shows when the main product form is out of viewport, hides at footer
{%- endcomment -%}

<div class="sticky-product-bar" data-sticky-product-bar aria-hidden="true">
  <div class="sticky-product-bar__progress"></div>
  <div class="sticky-product-bar__inner">
    <div class="sticky-product-bar__container">
      {%- comment -%} Product Image {%- endcomment -%}
      <div class="sticky-product-bar__image">
        {% if product.featured_image %}
          <img
            src="{{ product.featured_image | image_url: width: 120 }}"
            alt="{{ product.featured_image.alt | escape }}"
            width="60"
            height="60"
            loading="lazy"
            decoding="async"
            data-sticky-bar-image
          >
        {% endif %}
      </div>

      {%- comment -%} Product Info {%- endcomment -%}
      <div class="sticky-product-bar__info">
        <h3 class="sticky-product-bar__title">{{ product.title }}</h3>
        <div class="sticky-product-bar__meta">
          {% unless product.has_only_default_variant %}
            <span class="sticky-product-bar__variant" data-sticky-bar-variant>
              {{ current_variant.title }}
            </span>
          {% endunless %}
          <div class="sticky-product-bar__price">
            {% if current_variant.compare_at_price > current_variant.price %}
              <span class="sticky-product-bar__price-compare" data-sticky-bar-compare>
                {{ current_variant.compare_at_price | money }}
              </span>
            {% endif %}
            <span data-sticky-bar-price>{{ current_variant.price | money }}</span>
          </div>
        </div>
      </div>

      {%- comment -%} Actions {%- endcomment -%}
      <div class="sticky-product-bar__actions">
        {%- comment -%} Quantity Selector (Desktop only) {%- endcomment -%}
        <div class="sticky-product-bar__quantity">
          <button type="button" class="sticky-product-bar__qty-btn" data-sticky-bar-qty-minus aria-label="{{ 'products.product.decrease_quantity' | t }}">
            <i class="ph ph-minus"></i>
          </button>
          <input
            type="number"
            value="1"
            min="1"
            class="sticky-product-bar__qty-input border-0!"
            data-sticky-bar-qty-input
            aria-label="{{ 'products.product.quantity' | t }}"
          >
          <button type="button" class="sticky-product-bar__qty-btn" data-sticky-bar-qty-plus aria-label="{{ 'products.product.increase_quantity' | t }}">
            <i class="ph ph-plus"></i>
          </button>
        </div>

        {%- comment -%} Add to Cart Button {%- endcomment -%}
        <button
          type="button"
          class="btn btn--primary btn--sm"
          data-sticky-bar-add
          data-variant-id="{{ current_variant.id }}"
          {% unless current_variant.available %}disabled{% endunless %}
        >
          <i class="ph ph-bag" data-sticky-bar-icon></i>
          <span class="sticky-product-bar__btn-text" data-sticky-bar-text>
            {% if current_variant.available %}
              {{ 'products.product.add_to_cart' | t }}
            {% else %}
              {{ 'products.product.sold_out' | t }}
            {% endif %}
          </span>
        </button>
      </div>
    </div>
  </div>
</div>

<script>
(function() {
  // Remove any existing sticky bars from body (cleanup from previous page)
  document.querySelectorAll('body > [data-sticky-product-bar]').forEach(el => el.remove());

  const stickyBar = document.querySelector('[data-sticky-product-bar]');
  if (!stickyBar) return;

  // Move sticky bar to body to escape stacking context created by .site-content
  // This ensures it stays visible above the fixed footer reveal effect
  document.body.appendChild(stickyBar);

  const productForm = document.querySelector('[data-product-form]');
  const footerWrapper = document.querySelector('[data-footer-wrapper]');
  const footerSection = document.querySelector('[data-footer-section]');
  const siteContent = document.querySelector('.site-content');
  const addBtn = stickyBar.querySelector('[data-sticky-bar-add]');
  const qtyInput = stickyBar.querySelector('[data-sticky-bar-qty-input]');
  const qtyMinus = stickyBar.querySelector('[data-sticky-bar-qty-minus]');
  const qtyPlus = stickyBar.querySelector('[data-sticky-bar-qty-plus]');
  const priceEl = stickyBar.querySelector('[data-sticky-bar-price]');
  const compareEl = stickyBar.querySelector('[data-sticky-bar-compare]');
  const variantEl = stickyBar.querySelector('[data-sticky-bar-variant]');
  const imageEl = stickyBar.querySelector('[data-sticky-bar-image]');

  let isVisible = false;
  let currentVariantId = addBtn?.dataset.variantId;
  let currentVariantAvailable = {% if current_variant.available %}true{% else %}false{% endif %};

  // Format money helper
  const moneyFormat = {{ shop.money_format | json }};
  function formatMoney(cents) {
    const amount = (cents / 100).toFixed(2);
    return moneyFormat.replace(/\{\{\s*amount\s*\}\}/, amount)
                      .replace(/\{\{\s*amount_no_decimals\s*\}\}/, Math.round(cents / 100))
                      .replace(/\{\{\s*amount_with_comma_separator\s*\}\}/, amount.replace('.', ','));
  }

  // Visibility logic
  function updateVisibility() {
    if (!productForm) return;

    const formRect = productForm.getBoundingClientRect();
    const viewportHeight = window.innerHeight;

    // Form is above viewport (scrolled past)
    const formOutOfView = formRect.bottom < 100;

    // Check if we're near the bottom of the page (footer area)
    // This works reliably regardless of footer positioning (fixed reveal or normal)
    const scrollTop = window.scrollY || document.documentElement.scrollTop;
    const documentHeight = document.documentElement.scrollHeight;
    const threshold = 500; // Hide when within 500px of bottom
    const nearBottom = scrollTop + viewportHeight >= documentHeight - threshold;

    // Only show if variant is available (don't show for sold out variants)
    const shouldShow = formOutOfView && !nearBottom && currentVariantAvailable;

    if (shouldShow !== isVisible) {
      isVisible = shouldShow;
      stickyBar.classList.toggle('is-visible', isVisible);
      stickyBar.setAttribute('aria-hidden', !isVisible);
    }
  }

  // Quantity controls
  if (qtyMinus && qtyPlus && qtyInput) {
    qtyMinus.addEventListener('click', () => {
      const current = parseInt(qtyInput.value) || 1;
      if (current > 1) {
        qtyInput.value = current - 1;
      }
    });

    qtyPlus.addEventListener('click', () => {
      const current = parseInt(qtyInput.value) || 1;
      qtyInput.value = current + 1;
    });

    qtyInput.addEventListener('change', () => {
      const val = parseInt(qtyInput.value) || 1;
      qtyInput.value = Math.max(1, val);
    });
  }

  // Sync with main quantity input
  const mainQtyInput = document.querySelector('[data-quantity-input]');
  if (mainQtyInput && qtyInput) {
    mainQtyInput.addEventListener('change', () => {
      qtyInput.value = mainQtyInput.value;
    });

    qtyInput.addEventListener('change', () => {
      mainQtyInput.value = qtyInput.value;
    });
  }

  // Add to cart
  if (addBtn) {
    const btnIcon = addBtn.querySelector('[data-sticky-bar-icon]');
    const btnText = addBtn.querySelector('[data-sticky-bar-text]');
    const originalIconClass = btnIcon?.className || '';
    const originalText = btnText?.textContent || '';

    addBtn.addEventListener('click', async () => {
      if (addBtn.disabled) return;

      const quantity = parseInt(qtyInput?.value) || 1;
      const variantId = currentVariantId;

      if (!variantId) return;

      // Loading state
      stickyBar.classList.add('is-loading');
      addBtn.disabled = true;
      if (btnIcon) {
        btnIcon.className = 'ph ph-spinner animate-spin';
      }
      if (btnText) {
        btnText.textContent = '{{ 'cart.adding' | t }}';
      }

      try {
        const response = await fetch('/cart/add.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id: variantId,
            quantity: quantity
          })
        });

        if (!response.ok) throw new Error('Failed to add');

        const item = await response.json();

        // Get updated cart
        const cartResponse = await fetch('/cart.js');
        const cart = await cartResponse.json();

        // Update cart count
        document.querySelectorAll('[data-cart-count]').forEach(el => {
          el.textContent = cart.item_count;
          el.classList.toggle('hidden', cart.item_count === 0);
        });

        // Dispatch cart updated event for reactive components (e.g., free shipping bar)
        document.dispatchEvent(new CustomEvent('cart:updated', { detail: { cart } }));

        // Trigger cart behavior
        const cartType = window.themeSettings?.cartType || 'drawer';

        if (cartType === 'drawer') {
          if (window.refreshCartDrawer) {
            await window.refreshCartDrawer();
          }
          document.dispatchEvent(new CustomEvent('cart:open', { detail: { skipFetch: true } }));
        } else if (cartType === 'notification') {
          document.dispatchEvent(new CustomEvent('cart:notification', {
            detail: {
              product: {
                title: item.product_title,
                variant_title: item.variant_title !== 'Default Title' ? item.variant_title : null,
                image: item.image ? item.image.replace(/(\.[^.]+)$/, '_200x$1') : null
              },
              cart: cart
            }
          }));
        } else {
          window.location.href = window.routes?.cartUrl || '/cart';
          return;
        }

        // Success state
        if (btnIcon) {
          btnIcon.className = 'ph ph-check';
        }
        if (btnText) {
          btnText.textContent = '{{ 'cart.added' | t }}';
        }

        setTimeout(() => {
          if (btnIcon) {
            btnIcon.className = originalIconClass;
          }
          if (btnText) {
            btnText.textContent = originalText.trim();
          }
          addBtn.disabled = false;
        }, 1500);

      } catch (error) {
        console.error('Sticky bar add to cart error:', error);
        if (btnIcon) {
          btnIcon.className = 'ph ph-x';
        }
        if (btnText) {
          btnText.textContent = '{{ 'cart.error' | t }}';
        }

        setTimeout(() => {
          if (btnIcon) {
            btnIcon.className = originalIconClass;
          }
          if (btnText) {
            btnText.textContent = originalText.trim();
          }
          addBtn.disabled = false;
        }, 1500);
      } finally {
        stickyBar.classList.remove('is-loading');
      }
    });
  }

  // Listen for variant changes from main product section
  document.addEventListener('variant:change', (e) => {
    const variant = e.detail?.variant;
    if (!variant) return;

    currentVariantId = variant.id;
    currentVariantAvailable = variant.available;

    // Update price
    if (priceEl) {
      priceEl.textContent = formatMoney(variant.price);
    }

    // Update compare price
    if (compareEl) {
      if (variant.compare_at_price && variant.compare_at_price > variant.price) {
        compareEl.textContent = formatMoney(variant.compare_at_price);
        compareEl.style.display = '';
      } else {
        compareEl.style.display = 'none';
      }
    }

    // Update variant text
    if (variantEl && variant.title !== 'Default Title') {
      variantEl.textContent = variant.title;
    }

    // Update image if variant has one
    if (imageEl && variant.featured_image) {
      imageEl.src = variant.featured_image.src.replace(/(\.[^.]+)$/, '_120x$1');
    }

    // Update button state
    if (addBtn) {
      addBtn.disabled = !variant.available;
      const btnText = addBtn.querySelector('.sticky-product-bar__btn-text');
      if (btnText) {
        btnText.textContent = variant.available
          ? '{{ 'products.product.add_to_cart' | t }}'
          : '{{ 'products.product.sold_out' | t }}';
      }
    }

    // Update visibility (hide if variant not available)
    updateVisibility();
  });

  // Scroll listener with throttle
  let ticking = false;
  const onScroll = () => {
    if (!ticking) {
      requestAnimationFrame(() => {
        updateVisibility();
        ticking = false;
      });
      ticking = true;
    }
  };

  // Listen to native scroll
  window.addEventListener('scroll', onScroll, { passive: true });

  // Listen to Lenis scroll if available
  if (window.lenis) {
    window.lenis.on('scroll', onScroll);
  }

  // Initial check
  updateVisibility();

  // Reinitialize after Swup
  if (window.onSwupContentReplaced) {
    window.onSwupContentReplaced('sticky-product-bar', () => {
      updateVisibility();
      // Re-attach Lenis listener if it was recreated
      if (window.lenis) {
        window.lenis.on('scroll', onScroll);
      }
    });
  }
})();
</script>
