{%- liquid
  # Derive layout style from bento pattern setting
  if section.settings.enable_bento_pattern
    assign layout_style = 'metro'
  else
    assign layout_style = 'grid'
  endif
  assign full_width = section.settings.full_width
  assign enable_filtering = section.settings.enable_filtering
  assign enable_sorting = section.settings.enable_sorting

  capture container_class
    render 'container-class', full_width: full_width
  endcapture
-%}

{%- liquid
  # Convert image ratio setting to CSS aspect-ratio
  case settings.product_card_image_ratio
    when 'portrait'
      assign metro_aspect_ratio = '3/4'
    when 'square'
      assign metro_aspect_ratio = '1/1'
    when 'landscape'
      assign metro_aspect_ratio = '4/3'
    else
      assign metro_aspect_ratio = '3/4'
  endcase
-%}
<div
  class="collection-wrapper is-loading min-h-screen page-padding color-{{ section.settings.color_scheme }}"
  data-collection-wrapper
  data-layout-style="{{ layout_style }}"
  data-header-align="{{ section.settings.header_alignment }}"
  {% if settings.card_border_width == 0 %}data-card-no-border{% endif %}
  {% if settings.card_shadow == 'none' %}data-card-no-shadow{% endif %}
  {% if settings.product_card_image_ratio == 'adapt' %}data-metro-adapt{% endif %}
  style="--columns-desktop: {{ section.settings.columns_desktop }}; --columns-tablet: {{ section.settings.columns_tablet }}; --columns-mobile: {{ section.settings.columns_mobile }}; --metro-aspect-ratio: {{ metro_aspect_ratio }};"
>
  {%- liquid
    case section.settings.header_alignment
      when 'center'
        assign header_align_class = 'text-center'
      when 'right'
        assign header_align_class = 'text-right'
      else
        assign header_align_class = 'text-left'
    endcase
  -%}

  <header class="section-header-spacing {{ container_class }} {{ header_align_class }}">
    {% if section.settings.show_breadcrumbs %}
      {% render 'breadcrumbs', alignment: section.settings.header_alignment %}
    {% endif %}
    <h1 class="page-title" data-collection-title>
      {{ collection.title }}
    </h1>

    {% if section.settings.show_product_count %}
      <p class="page-header-subtitle">
        <span class="page-header-subtitle-line" data-subtitle-line></span>
        <span class="overflow-hidden"><span class="inline-block" data-subtitle-text>{{ 'collections.product_count' | t: count: collection.products_count }}</span></span>
      </p>
    {% endif %}

    {% if section.settings.show_description and collection.description != blank %}
      {%- assign desc_text = collection.description | strip_html -%}
      {%- capture desc_align_class -%}
        {%- case section.settings.header_alignment -%}
          {%- when 'center' -%}mx-auto text-center
          {%- when 'right' -%}ml-auto text-right
          {%- else -%}text-left
        {%- endcase -%}
      {%- endcapture -%}
      <div class="mt-8 max-w-[380px] text-sm{% if settings.headings_uppercase %} uppercase{% endif %} tracking-wider leading-relaxed text-(--color-text-secondary) pl-[0.15em] {{ desc_align_class }}"{% if section.settings.enable_description_shuffle %} data-shuffle-text data-original-text="{{ desc_text | escape }}"{% else %} data-tween data-tween-type="fade-up"{% endif %}>
        {{ desc_text }}
      </div>
    {% endif %}
  </header>

  {% paginate collection.products by section.settings.products_per_page %}

    {%- comment -%} Filters and Sorting {%- endcomment -%}
    {% if enable_filtering or enable_sorting or section.settings.enable_layout_toggle %}
      <div class="{{ container_class }}">
        {% render 'facets',
          results: collection,
          enable_filtering: enable_filtering,
          enable_sorting: enable_sorting,
          enable_layout_toggle: section.settings.enable_layout_toggle,
          section_id: section.id
        %}
      </div>
    {% endif %}

    <div id="ProductGridContainer" data-product-grid-container>
    {% case layout_style %}

      {% when 'metro' %}
        <div class="collection-metro grid {{ container_class }}" data-collection-content data-metro-cols="{{ section.settings.columns_desktop }}" style="--columns-desktop: {{ section.settings.columns_desktop }}; --columns-tablet: {{ section.settings.columns_tablet }}; --columns-mobile: {{ section.settings.columns_mobile }};" aria-live="polite" aria-busy="false">
          {% for product in collection.products %}
            {%- liquid
              # Modern bento pattern - adapts to column count
              assign item_class = 'metro-item--standard'
              assign cols = section.settings.columns_desktop

              # Bento pattern is always enabled in metro mode (since enable_bento_pattern controls metro mode)
              if cols >= 4
                # For 4+ columns: bento with hero (2x2) only
                assign mod = forloop.index0 | modulo: 8
                if mod == 0
                  assign item_class = 'metro-item--hero'
                endif
              elsif cols == 3
                # For 3 columns: simplified pattern with hero only
                assign mod3 = forloop.index0 | modulo: 6
                if mod3 == 0
                  assign item_class = 'metro-item--hero'
                endif
              elsif cols == 2
                # For 2 columns: only hero items (full width, 2 rows)
                assign mod2 = forloop.index0 | modulo: 4
                if mod2 == 0
                  assign item_class = 'metro-item--hero'
                endif
              endif

              if collection
                assign product_url = product.url | within: collection
              else
                assign product_url = product.url
              endif

              assign is_on_sale = false
              if product.compare_at_price > product.price
                assign is_on_sale = true
                assign save_percent = product.compare_at_price | minus: product.price | times: 100.0 | divided_by: product.compare_at_price | round
              endif

              assign first_variant = product.selected_or_first_available_variant
              assign has_variants = false
              if product.variants.size > 1
                assign has_variants = true
              endif

              assign has_second_image = false
              if product.images.size > 1
                assign has_second_image = true
              endif
            -%}

            <div
              class="metro-item {{ item_class }}{% unless product.available %} metro-item-soldout{% endunless %}{% if has_second_image %} metro-item--has-secondary{% endif %}"
              data-collection-item="{{ forloop.index0 }}"
              data-product-id="{{ product.id }}"
            >
              {%- comment -%} Card link - covers images and text content {%- endcomment -%}
              <a href="{{ product_url }}" class="metro-item-inner block no-underline">
                {%- comment -%} Images {%- endcomment -%}
                {% if product.featured_image %}
                  {%- assign focal_point = product.featured_image.presentation.focal_point | default: '50% 50%' -%}
                  {%- assign focal_style = 'object-position: ' | append: focal_point -%}
                  {%- assign second_image = product.images[1] -%}

                  {%- comment -%} Primary Image {%- endcomment -%}
                  {{ product.featured_image | image_url: width: 1400 | image_tag:
                    class: 'metro-item-image metro-item-image--primary',
                    style: focal_style,
                    loading: 'lazy',
                    decoding: 'async',
                    sizes: '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw',
                    widths: '400, 600, 800, 1200, 1400',
                    alt: product.featured_image.alt | default: product.title
                  }}

                  {%- comment -%} Secondary Image (hover) {%- endcomment -%}
                  {% if has_second_image %}
                    {%- assign focal_point_2 = second_image.presentation.focal_point | default: '50% 50%' -%}
                    {%- assign focal_style_2 = 'object-position: ' | append: focal_point_2 -%}
                    {{ second_image | image_url: width: 1400 | image_tag:
                      class: 'metro-item-image metro-item-image--secondary',
                      style: focal_style_2,
                      loading: 'lazy',
                      decoding: 'async',
                      sizes: '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw',
                      widths: '400, 600, 800, 1200, 1400',
                      alt: second_image.alt | default: product.title
                    }}
                  {% endif %}
                {% else %}
                  <div class="metro-item-image flex items-center justify-center">
                    <i class="ph ph-image text-6xl text-white/20"></i>
                  </div>
                {% endif %}

                {%- comment -%} Overlay {%- endcomment -%}
                <div class="metro-item-overlay"></div>

                {%- comment -%} Content (text only - no buttons) {%- endcomment -%}
                <div class="metro-item-content">
                  {%- comment -%} Vendor {%- endcomment -%}
                  {% if settings.show_vendor and product.vendor != blank %}
                    <p class="metro-item-vendor{% if settings.buttons_uppercase %} uppercase{% endif %}">{{ product.vendor }}</p>
                  {% endif %}

                  {%- comment -%} Title {%- endcomment -%}
                  <h3 class="metro-item-title font-heading">{{ product.title }}</h3>

                  {%- comment -%} Price {%- endcomment -%}
                  <div class="metro-item-price">
                    {% if is_on_sale %}
                      <span class="metro-item-price-compare">{{ product.compare_at_price | money }}</span>
                      <span class="metro-item-price-sale">{{ product.price | money }}</span>
                    {% else %}
                      <span>{{ product.price | money }}</span>
                    {% endif %}
                  </div>
                </div>
              </a>

              {%- comment -%} Badges - positioned outside <a> to avoid overflow clipping {%- endcomment -%}
              <div class="metro-item-badges">
                {% unless product.available %}
                  {% if settings.show_sold_out_badge %}
                    <span class="metro-item-badge metro-item-badge--soldout">
                      {{ 'products.product.sold_out' | t }}
                    </span>
                  {% endif %}
                {% endunless %}
                {% if is_on_sale and settings.show_sale_badge %}
                  <span class="metro-item-badge metro-item-badge--sale">
                    {% if settings.sale_badge_style == 'percentage' %}
                      -{{ save_percent }}%
                    {% else %}
                      {{ 'products.product.on_sale' | t }}
                    {% endif %}
                  </span>
                {% endif %}
              </div>

              {%- comment -%} Action buttons - positioned outside <a> to avoid nested links {%- endcomment -%}
              <div class="metro-item-actions-wrapper">
                <div class="metro-item-actions">
                  {%- comment -%} Quick Add (single variant) or Select Options (multiple variants) {%- endcomment -%}
                  {% if product.available %}
                    {% if has_variants %}
                      {%- comment -%} Select Options - navigates to product page for variant selection {%- endcomment -%}
                      <a
                        href="{{ product_url }}"
                        class="metro-item-action"
                        aria-label="{{ 'products.product.select_options' | t }}: {{ product.title }}"
                      >
                        <i class="ph ph-sliders-horizontal text-lg"></i>
                      </a>
                    {% else %}
                      {%- comment -%} Quick Add - single variant {%- endcomment -%}
                      <button
                        type="button"
                        class="metro-item-action"
                        data-quick-add="{{ first_variant.id }}"
                        aria-label="{{ 'products.product.add_to_cart' | t }}: {{ product.title }}"
                      >
                        <i class="ph ph-bag text-lg icon-default"></i>
                        <i class="ph ph-spinner text-lg icon-loading"></i>
                        <i class="ph ph-check text-lg icon-added"></i>
                      </button>
                    {% endif %}
                  {% endif %}

                  {%- comment -%} Quick View {%- endcomment -%}
                  {% if settings.enable_quick_view and product.available %}
                    <button
                      type="button"
                      class="metro-item-action"
                      data-quick-view-trigger="{{ product.handle }}"
                      aria-label="{{ 'products.product.quick_view' | t }}"
                    >
                      <i class="ph ph-eye text-lg"></i>
                    </button>
                  {% endif %}

                  {%- comment -%} Wishlist {%- endcomment -%}
                  {% if settings.enable_wishlist %}
                    {%- capture wishlist_json -%}{"id":{{ product.id | json }},"handle":{{ product.handle | json }},"title":{{ product.title | json }},"url":{{ product.url | json }},"image":{{ product.featured_image | image_url: width: 800 | json }},"price":{{ product.price | json }},"compareAtPrice":{{ product.compare_at_price | default: 0 | json }},"vendor":{{ product.vendor | json }},"available":{{ product.available | json }}}{%- endcapture -%}
                    <button
                      type="button"
                      class="metro-item-action product-card-wishlist"
                      data-wishlist-toggle="{{ product.id }}"
                      data-product-json='{{ wishlist_json | strip_newlines | replace: "'", "&#39;" }}'
                      aria-label="{{ 'products.wishlist.add_to_wishlist' | t }}"
                    >
                      <i class="ph ph-heart text-lg"></i>
                    </button>
                  {% endif %}

                  {%- comment -%} Compare {%- endcomment -%}
                  {% if settings.enable_compare %}
                    {%- capture compare_json -%}{"id":{{ product.id | json }},"handle":{{ product.handle | json }},"title":{{ product.title | json }},"url":{{ product.url | json }},"image":{{ product.featured_image | image_url: width: 800 | json }},"price":{{ product.price | json }},"compareAtPrice":{{ product.compare_at_price | default: 0 | json }},"vendor":{{ product.vendor | json }},"type":{{ product.type | json }},"sku":{{ product.selected_or_first_available_variant.sku | json }},"available":{{ product.available | json }}}{%- endcapture -%}
                    <button
                      type="button"
                      class="metro-item-action product-card-compare"
                      data-compare-toggle="{{ product.id }}"
                      data-product-json='{{ compare_json | strip_newlines | replace: "'", "&#39;" }}'
                      aria-label="{{ 'products.compare.add_to_compare' | t }}"
                    >
                      <i class="ph ph-scales text-lg"></i>
                    </button>
                  {% endif %}
                </div>
              </div>
            </div>
          {% endfor %}
        </div>

      {% else %}
        <div class="collection-grid grid gap-8 {{ container_class }}" data-collection-content aria-live="polite" aria-busy="false">
          {% for product in collection.products %}
            {% render 'product-card', product: product, collection: collection, index: forloop.index0 %}
            {% unless forloop.last %}
              <hr class="collection-grid__divider hidden border-(--color-border)">
            {% endunless %}
          {% endfor %}
        </div>

    {% endcase %}

      {%- comment -%} Unified List View - Used by both grid and metro when in list mode {%- endcomment -%}
      {% if section.settings.enable_layout_toggle %}
        <div class="collection-list-view hidden {{ container_class }}" data-collection-list-content aria-live="polite" aria-busy="false">
          {% for product in collection.products %}
            {% render 'product-card-list', product: product, collection: collection, index: forloop.index0 %}
          {% endfor %}
        </div>
      {% endif %}

    </div>{%- comment -%} End ProductGridContainer {%- endcomment -%}

    {% if paginate.pages > 1 %}
      {% if section.settings.pagination_type == 'load_more' %}
        <div class="flex flex-col items-center justify-center pt-(--section-vertical-padding) {{ container_class }}" data-pagination-load-more>
          {% if paginate.next %}
            <button type="button" class="load-more-btn btn btn--secondary" data-next-url="{{ paginate.next.url }}">
              <span class="load-more-text">{{ 'general.load_more' | t }}</span>
              <span class="load-more-loading hidden items-center">
                <svg class="animate-spin -ml-1 mr-2 h-3 w-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                {{ 'accessibility.loading' | t }}
              </span>
            </button>
          {% endif %}
          {%- assign showing_from = paginate.current_offset | plus: 1 -%}
          {%- assign showing_to = paginate.current_offset | plus: paginate.page_size | at_most: paginate.items -%}
          <span class="mt-4 text-sm text-(--color-text-secondary)" data-products-showing>
            {{ 'general.showing_products' | t: from: showing_from, to: showing_to, total: paginate.items }}
          </span>
        </div>
      {% else %}
        <nav class="flex items-center justify-center gap-4 py-16 {{ container_class }}">
          {%- assign btn_previous = 'general.previous' | t -%}
          {%- assign btn_next = 'general.next' | t -%}
          {% if paginate.previous %}
            <a href="{{ paginate.previous.url }}" class="btn btn--secondary btn--sm">
              <i class="ph ph-arrow-left"></i>
              {% render 'button-text', text: btn_previous %}
            </a>
          {% endif %}

          <span class="px-4 py-2 text-sm text-(--color-text-secondary)">
            {{ 'general.page_of' | t: current: paginate.current_page, total: paginate.pages }}
          </span>

          {% if paginate.next %}
            <a href="{{ paginate.next.url }}" class="btn btn--secondary btn--sm">
              {% render 'button-text', text: btn_next %}
              <i class="ph ph-arrow-right"></i>
            </a>
          {% endif %}
        </nav>
      {% endif %}
    {% endif %}

  {% endpaginate %}
</div>

<script>
(function() {
  const wrapper = document.querySelector('[data-collection-wrapper]');
  if (!wrapper) return;
  if (wrapper.dataset.collectionInitialized) return;
  wrapper.dataset.collectionInitialized = 'true';

  // Metro card action buttons - prevent link navigation and handle clicks
  // Use capture phase to intercept before the link would navigate
  wrapper.addEventListener('click', function(e) {
    const actionBtn = e.target.closest('.metro-item-action');
    if (!actionBtn) return;

    // Prevent the parent <a> from navigating
    e.preventDefault();

    // Handle navigate button (Select Options) - these don't have other handlers
    const navigateUrl = actionBtn.dataset.navigate;
    if (navigateUrl) {
      e.stopPropagation();
      window.location.href = navigateUrl;
    }
    // Don't stop propagation for quick-add, quick-view, wishlist, compare
    // They have their own document-level handlers that need the event
  }, true); // Use capture phase

  // Ensure GSAP is available globally (from pieces bundle)
  if (typeof gsap === 'undefined' && window.pieces && window.pieces.gsap) {
    window.gsap = window.pieces.gsap;
    window.ScrollTrigger = window.pieces.ScrollTrigger;
    window.SplitText = window.pieces.SplitText;
  }

  // If animations disabled, just show content immediately but still init load more
  if (typeof window.shouldAnimate === 'function' && !window.shouldAnimate()) {
    wrapper.classList.remove('is-loading');
    initLoadMoreNoAnimation();

    // Reinitialize load more when facets are updated (filters applied/cleared)
    document.addEventListener('facets:updated', () => {
      requestAnimationFrame(() => {
        initLoadMoreNoAnimation();
      });
    });
    return;
  }

  // Load more functionality without animations
  function initLoadMoreNoAnimation() {
    const loadMoreContainer = wrapper.querySelector('[data-pagination-load-more]');
    if (!loadMoreContainer) return;

    const loadMoreBtn = loadMoreContainer.querySelector('.load-more-btn');
    if (!loadMoreBtn) return;

    loadMoreBtn.addEventListener('click', async function() {
      const nextUrl = this.dataset.nextUrl;
      if (!nextUrl) return;

      const textSpan = this.querySelector('.load-more-text');
      const loadingSpan = this.querySelector('.load-more-loading');

      // Show loading state
      textSpan.classList.add('hidden');
      loadingSpan.classList.remove('hidden');
      loadingSpan.classList.add('inline-flex');
      this.disabled = true;

      // Set aria-busy for screen readers
      const contentContainer = wrapper.querySelector('[data-collection-content]');
      const listContainer = wrapper.querySelector('[data-collection-list-content]');
      if (contentContainer) contentContainer.setAttribute('aria-busy', 'true');
      if (listContainer) listContainer.setAttribute('aria-busy', 'true');

      try {
        // Fetch the next page
        const response = await fetch(nextUrl);
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Get new products from the fetched page
        const newWrapper = doc.querySelector('[data-collection-wrapper]');
        const contentContainer = wrapper.querySelector('[data-collection-content]');
        const listContainer = wrapper.querySelector('[data-collection-list-content]');
        const newContent = newWrapper?.querySelector('[data-collection-content]');
        const newListContent = newWrapper?.querySelector('[data-collection-list-content]');

        if (newContent && contentContainer) {
          const newItems = newContent.querySelectorAll('[data-collection-item], [data-product-card]');

          // Append new items to the grid/metro container
          newItems.forEach((item) => {
            // Add divider before each item (for list view)
            const divider = document.createElement('hr');
            divider.className = 'collection-grid__divider hidden border-(--color-border)';
            contentContainer.appendChild(divider);

            // Clone and append
            const clone = item.cloneNode(true);

            // Remove data-tween attributes - animations disabled so cards should show immediately
            clone.removeAttribute('data-tween');
            clone.removeAttribute('data-tween-type');
            clone.querySelectorAll('[data-tween]').forEach(el => {
              el.removeAttribute('data-tween');
              el.removeAttribute('data-tween-type');
            });

            contentContainer.appendChild(clone);
          });

          // Also append to unified list view container if it exists
          if (listContainer && newListContent) {
            const newListItems = newListContent.querySelectorAll('.product-card-list');
            newListItems.forEach((item) => {
              const clone = item.cloneNode(true);

              // Remove data-tween attributes - animations disabled
              clone.removeAttribute('data-tween');
              clone.removeAttribute('data-tween-type');
              clone.querySelectorAll('[data-tween]').forEach(el => {
                el.removeAttribute('data-tween');
                el.removeAttribute('data-tween-type');
              });

              listContainer.appendChild(clone);
            });
          }

          // Update the pagination
          const newPagination = newWrapper.querySelector('[data-pagination-load-more]');
          if (newPagination) {
            loadMoreContainer.innerHTML = newPagination.innerHTML;
            // Reinitialize load more for the new button
            initLoadMoreNoAnimation();
          } else {
            // No more pages, hide the button
            loadMoreBtn.style.display = 'none';
          }

          // Update the count text
          const countSpan = loadMoreContainer.querySelector('span:last-child');
          const newCountSpan = newPagination?.querySelector('span:last-child');
          if (countSpan && newCountSpan) {
            countSpan.textContent = newCountSpan.textContent;
          }

          // Refresh Lenis scroll bounds
          if (window.pieces && window.pieces.lenis) {
            window.pieces.lenis.resize();
          }

          // Clear aria-busy after content loaded
          if (contentContainer) contentContainer.setAttribute('aria-busy', 'false');
          if (listContainer) listContainer.setAttribute('aria-busy', 'false');
        }
      } catch (error) {
        console.error('Error loading more products:', error);
        // Reset button state on error
        textSpan.classList.remove('hidden');
        loadingSpan.classList.add('hidden');
        loadingSpan.classList.remove('inline-flex');
        this.disabled = false;
        // Clear aria-busy on error
        const contentContainer = wrapper.querySelector('[data-collection-content]');
        const listContainer = wrapper.querySelector('[data-collection-list-content]');
        if (contentContainer) contentContainer.setAttribute('aria-busy', 'false');
        if (listContainer) listContainer.setAttribute('aria-busy', 'false');
      }
    });
  }

  const layoutStyle = wrapper.dataset.layoutStyle;

  function initCollection() {
    if (typeof gsap === 'undefined') {
      if (window.pieces && window.pieces.gsap) {
        window.gsap = window.pieces.gsap;
      } else {
        setTimeout(initCollection, 100);
        return;
      }
    }

    // Get SplitText from pieces or window
    let SplitText = window.SplitText;
    if (!SplitText && window.pieces && window.pieces.SplitText) {
      SplitText = window.pieces.SplitText;
    }

    if (!SplitText) {
      setTimeout(initCollection, 100);
      return;
    }

    const items = wrapper.querySelectorAll('[data-collection-item], [data-product-card]');
    let isAnimating = false;

    // Get ScrollTrigger from pieces or window
    const ScrollTrigger = window.ScrollTrigger || (window.pieces && window.pieces.ScrollTrigger);

    // Header intro animation (always runs immediately)
    function runHeaderAnimation() {
      const tl = gsap.timeline();

      // Header title - use SplitText for natural line breaks
      const title = wrapper.querySelector('[data-collection-title]');
      if (title) {
        const split = new SplitText(title, { type: 'lines', linesClass: 'collection-header-title-line' });

        // Wrap each line in an overflow-hidden container for the reveal effect
        // Add padding to prevent descender letters (y, g, p, q) from being clipped
        split.lines.forEach(line => {
          const lineWrapper = document.createElement('div');
          lineWrapper.style.overflow = 'hidden';
          lineWrapper.style.display = 'block';
          lineWrapper.style.paddingBottom = '0.25em';
          lineWrapper.style.marginBottom = '-0.25em';
          line.parentNode.insertBefore(lineWrapper, line);
          lineWrapper.appendChild(line);
        });

        gsap.set(split.lines, { yPercent: 120 });
        tl.to(split.lines, {
          yPercent: 0,
          duration: 1.2,
          ease: 'power4.out',
          stagger: 0.1
        }, 0);
      }

      // Subtitle line draw animation
      const subtitleLine = wrapper.querySelector('[data-subtitle-line]');
      if (subtitleLine) {
        gsap.set(subtitleLine, { scaleX: 0, transformOrigin: 'left center' });
        tl.to(subtitleLine, {
          scaleX: 1,
          duration: 0.8,
          ease: 'power3.out'
        }, 0.4);
      }

      // Subtitle text reveal
      const subtitleText = wrapper.querySelector('[data-subtitle-text]');
      if (subtitleText) {
        gsap.set(subtitleText, { yPercent: 120 });
        tl.to(subtitleText, {
          yPercent: 0,
          duration: 0.8,
          ease: 'power4.out'
        }, 0.6);
      }

      // Header description - fade in with text shuffle animation
      const headerDesc = wrapper.querySelector('[data-shuffle-text]');
      if (headerDesc) {
        // Use data attribute for original text (survives Swup navigation)
        const originalText = headerDesc.dataset.originalText || headerDesc.textContent.trim();
        const chars = {% if settings.headings_uppercase %}'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*'{% else %}'abcdefghijklmnopqrstuvwxyz0123456789!@#$%&*'{% endif %};

        // Lock height before animation to prevent layout shifts
        const initialHeight = headerDesc.offsetHeight;
        headerDesc.style.height = initialHeight + 'px';

        // Start with scrambled text and hidden
        headerDesc.textContent = originalText.split('').map(char =>
          char === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)]
        ).join('');
        gsap.set(headerDesc, { opacity: 0 });

        // Fade in
        tl.to(headerDesc, {
          opacity: 1,
          duration: 0.4,
          ease: 'power2.out'
        }, 0.6);

        // Shuffle animation - characters reveal left to right with scrambling
        const shuffleObj = { progress: 0 };
        tl.to(shuffleObj, {
          progress: 1,
          duration: 1.8,
          ease: 'none',
          onUpdate: () => {
            const progress = shuffleObj.progress;
            const revealedCount = Math.floor(progress * originalText.length);

            headerDesc.textContent = originalText.split('').map((char, i) => {
              if (char === ' ') return ' ';
              if (i < revealedCount) return char;
              // Keep scrambling unrevealed characters
              return chars[Math.floor(Math.random() * chars.length)];
            }).join('');
          },
          onComplete: () => {
            headerDesc.textContent = originalText;
            // Remove fixed height after animation completes
            headerDesc.style.height = '';
          }
        }, 0.6);
      }
    }

    // Animate single product card when it enters viewport
    function animateProductCard(item) {
      const imgWrap = item.querySelector('.product-card-image');
      const titleSpans = item.querySelectorAll('.product-card-title .overflow-hidden span');
      const priceSpans = item.querySelectorAll('.product-card-price .overflow-hidden span');

      const tl = gsap.timeline();

      // Horizontal reveal - clip from left to right
      if (imgWrap) {
        tl.to(imgWrap, {
          clipPath: 'inset(0 0% 0 0)',
          duration: 1.2,
          ease: 'power3.out'
        }, 0);
      }

      // Split text reveal for title words
      if (titleSpans.length) {
        tl.to(titleSpans, {
          yPercent: 0,
          duration: 0.8,
          ease: 'power4.out',
          stagger: 0.05
        }, 0.2);
      }

      // Split text reveal for price
      if (priceSpans.length) {
        tl.to(priceSpans, {
          yPercent: 0,
          duration: 0.6,
          ease: 'power4.out',
          stagger: 0.05
        }, 0.3);
      }
    }

    // Animate single metro item when it enters viewport
    function animateMetroItem(item) {
      const inner = item.querySelector('.metro-item-inner');
      if (inner) {
        gsap.to(inner, {
          clipPath: 'inset(0 0% 0 0)',
          duration: 1.2,
          ease: 'power3.out'
        });
      }
    }

    // Check if element is in viewport
    function isInViewport(element, threshold = 0.85) {
      const rect = element.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      // Element is in viewport if its top is above the threshold line
      return rect.top < windowHeight * threshold;
    }

    // Check if we're in a Swup transition
    function isSwupTransitioning() {
      return document.documentElement.classList.contains('is-changing');
    }

    // Set initial states and create ScrollTriggers for each item
    function initScrollAnimations() {
      // Get column count for stagger calculation
      const columnsDesktop = parseInt(wrapper.style.getPropertyValue('--columns-desktop')) || 4;
      const columnsTablet = parseInt(wrapper.style.getPropertyValue('--columns-tablet')) || 2;
      const columnsMobile = parseInt(wrapper.style.getPropertyValue('--columns-mobile')) || 1;

      // Determine current column count based on viewport
      function getColumnCount() {
        if (window.innerWidth >= 1024) return columnsDesktop;
        if (window.innerWidth >= 768) return columnsTablet;
        return columnsMobile;
      }

      const cols = getColumnCount();
      const scrollStart = window.getScrollStart ? window.getScrollStart('top 85%') : 'top 85%';

      if (layoutStyle === 'metro') {
        // Metro: Set initial clip-path and create ScrollTrigger per item
        const inViewItems = [];
        const outOfViewItems = [];

        // During Swup transition, getBoundingClientRect may be inaccurate
        const transitioning = isSwupTransitioning();
        const rowsInViewport = transitioning ? Math.ceil(window.innerHeight / 300) + 1 : Infinity;
        const maxInitialItems = transitioning ? rowsInViewport * cols : Infinity;

        items.forEach((item, index) => {
          const inner = item.querySelector('.metro-item-inner');
          if (inner) {
            gsap.set(inner, { clipPath: 'inset(0 100% 0 0)' });
          }

          // During Swup transition, assume first N items are in viewport
          const wouldBeInViewport = transitioning ? index < maxInitialItems : isInViewport(item);

          if (wouldBeInViewport) {
            inViewItems.push({ item, index });
          } else {
            outOfViewItems.push({ item, index });
          }
        });

        // Remove is-loading AFTER setting initial states to prevent flash
        wrapper.classList.remove('is-loading');

        // Animate items already in viewport immediately with stagger
        // During Swup transition, add extra delay to sync with page reveal
        const baseDelay = transitioning ? 0.3 : 0;
        inViewItems.forEach(({ item, index }, i) => {
          const colIndex = index % cols;
          const delay = baseDelay + (colIndex * 0.08);
          gsap.delayedCall(delay, () => animateMetroItem(item));
        });

        // Create ScrollTriggers only for items not yet in viewport
        outOfViewItems.forEach(({ item, index }) => {
          ScrollTrigger.create({
            trigger: item,
            start: scrollStart,
            once: true,
            onEnter: () => {
              const colIndex = index % cols;
              const delay = colIndex * 0.08;
              gsap.delayedCall(delay, () => animateMetroItem(item));
            }
          });
        });
      } else {
        // Grid: Set initial states and create ScrollTrigger per card
        const inViewItems = [];
        const outOfViewItems = [];

        // During Swup transition, getBoundingClientRect may be inaccurate
        // Calculate how many rows would fit in viewport (assuming scroll at top)
        const transitioning = isSwupTransitioning();
        const rowsInViewport = transitioning ? Math.ceil(window.innerHeight / 400) + 1 : Infinity;
        const itemsPerRow = cols;
        const maxInitialItems = transitioning ? rowsInViewport * itemsPerRow : Infinity;

        items.forEach((item, index) => {
          const imgWrap = item.querySelector('.product-card-image');
          const titleSpans = item.querySelectorAll('.product-card-title .overflow-hidden span');
          const priceSpans = item.querySelectorAll('.product-card-price .overflow-hidden span');

          // Set initial states
          if (imgWrap) {
            gsap.set(imgWrap, { clipPath: 'inset(0 100% 0 0)' });
          }
          if (titleSpans.length) {
            gsap.set(titleSpans, { yPercent: 100 });
          }
          if (priceSpans.length) {
            gsap.set(priceSpans, { yPercent: 100 });
          }

          // During Swup transition, assume first N items are in viewport (page scrolls to top)
          // Otherwise, use actual viewport check
          const wouldBeInViewport = transitioning ? index < maxInitialItems : isInViewport(item);

          if (wouldBeInViewport) {
            inViewItems.push({ item, index });
          } else {
            outOfViewItems.push({ item, index });
          }
        });

        // Remove is-loading AFTER setting initial states to prevent flash
        wrapper.classList.remove('is-loading');

        // Animate items already in viewport immediately with stagger
        // During Swup transition, add extra delay to sync with page reveal
        const baseDelay = transitioning ? 0.3 : 0;
        inViewItems.forEach(({ item, index }) => {
          const colIndex = index % cols;
          const delay = baseDelay + (colIndex * 0.1);
          gsap.delayedCall(delay, () => animateProductCard(item));
        });

        // Create ScrollTriggers only for items not yet in viewport
        outOfViewItems.forEach(({ item, index }) => {
          ScrollTrigger.create({
            trigger: item,
            start: scrollStart,
            once: true,
            onEnter: () => {
              const colIndex = index % cols;
              const delay = colIndex * 0.1;
              gsap.delayedCall(delay, () => animateProductCard(item));
            }
          });
        });
      }
    }

    // Run animations
    runHeaderAnimation();
    initScrollAnimations();

    // Refresh ScrollTrigger after creating new triggers (important for Swup navigation)
    if (ScrollTrigger) {
      requestAnimationFrame(() => {
        ScrollTrigger.refresh();
      });
    }

    // Load More functionality
    function initLoadMore() {
      const loadMoreContainer = wrapper.querySelector('[data-pagination-load-more]');
      if (!loadMoreContainer) return;

      const loadMoreBtn = loadMoreContainer.querySelector('.load-more-btn');
      if (!loadMoreBtn) return;

      loadMoreBtn.addEventListener('click', async function() {
        const nextUrl = this.dataset.nextUrl;
        if (!nextUrl || isAnimating) return;

        const textSpan = this.querySelector('.load-more-text');
        const loadingSpan = this.querySelector('.load-more-loading');

        // Show loading state
        textSpan.classList.add('hidden');
        loadingSpan.classList.remove('hidden');
        loadingSpan.classList.add('inline-flex');
        this.disabled = true;

        try {
          // Fetch the next page
          const response = await fetch(nextUrl);
          const html = await response.text();
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');

          // Get new products from the fetched page
          const newWrapper = doc.querySelector('[data-collection-wrapper]');
          const contentContainer = wrapper.querySelector('[data-collection-content]');
          const listContainer = wrapper.querySelector('[data-collection-list-content]');
          const newContent = newWrapper?.querySelector('[data-collection-content]');
          const newListContent = newWrapper?.querySelector('[data-collection-list-content]');

          if (newContent && contentContainer) {
            const newItems = newContent.querySelectorAll('[data-collection-item], [data-product-card]');
            const cols = getColumnCount();

            // Append new items to the grid/metro container
            newItems.forEach((item, index) => {
              // Add divider before each item (for list view)
              // This creates the <hr> elements that are shown in list view
              const divider = document.createElement('hr');
              divider.className = 'collection-grid__divider hidden border-(--color-border)';
              contentContainer.appendChild(divider);

              // Clone and append
              const clone = item.cloneNode(true);

              // Remove data-tween attributes from cloned cards since we handle animations manually
              // This prevents TweenManager.reinit() from setting opacity: 0 on these cards
              clone.removeAttribute('data-tween');
              clone.removeAttribute('data-tween-type');
              clone.querySelectorAll('[data-tween]').forEach(el => {
                el.removeAttribute('data-tween');
                el.removeAttribute('data-tween-type');
              });

              contentContainer.appendChild(clone);

              // Set initial states for animation
              if (layoutStyle === 'metro') {
                const inner = clone.querySelector('.metro-item-inner');
                if (inner) {
                  gsap.set(inner, { clipPath: 'inset(0 100% 0 0)' });
                }
              } else {
                const imgWrap = clone.querySelector('.product-card-image');
                const titleSpans = clone.querySelectorAll('.product-card-title .overflow-hidden span');
                const priceSpans = clone.querySelectorAll('.product-card-price .overflow-hidden span');

                if (imgWrap) gsap.set(imgWrap, { clipPath: 'inset(0 100% 0 0)' });
                if (titleSpans.length) gsap.set(titleSpans, { yPercent: 100 });
                if (priceSpans.length) gsap.set(priceSpans, { yPercent: 100 });
              }

              // Animate in with stagger
              const colIndex = index % cols;
              const delay = colIndex * 0.1;

              gsap.delayedCall(delay, () => {
                if (layoutStyle === 'metro') {
                  animateMetroItem(clone);
                } else {
                  animateProductCard(clone);
                }
              });

            });

            // Also append to unified list view container if it exists
            if (listContainer && newListContent) {
              const newListItems = newListContent.querySelectorAll('.product-card-list');
              newListItems.forEach((item) => {
                const clone = item.cloneNode(true);

                // Remove data-tween attributes - we don't animate list items on load more
                clone.removeAttribute('data-tween');
                clone.removeAttribute('data-tween-type');
                clone.querySelectorAll('[data-tween]').forEach(el => {
                  el.removeAttribute('data-tween');
                  el.removeAttribute('data-tween-type');
                });

                listContainer.appendChild(clone);
              });
            }

            // Update the pagination
            const newPagination = newWrapper.querySelector('[data-pagination-load-more]');
            if (newPagination) {
              loadMoreContainer.innerHTML = newPagination.innerHTML;
              // Reinitialize load more for the new button
              initLoadMore();
            } else {
              // No more pages, hide the button
              loadMoreBtn.style.display = 'none';
            }

            // Update the count text
            const countSpan = loadMoreContainer.querySelector('span:last-child');
            const newCountSpan = newPagination?.querySelector('span:last-child');
            if (countSpan && newCountSpan) {
              countSpan.textContent = newCountSpan.textContent;
            }

            // Refresh Lenis scroll bounds
            if (window.pieces && window.pieces.lenis) {
              window.pieces.lenis.resize();
            }
          }
        } catch (error) {
          console.error('Error loading more products:', error);
          // Reset button state on error
          textSpan.classList.remove('hidden');
          loadingSpan.classList.add('hidden');
          loadingSpan.classList.remove('inline-flex');
          this.disabled = false;
        }
      });
    }

    // Helper function accessible to load more
    function getColumnCount() {
      const columnsDesktop = parseInt(wrapper.style.getPropertyValue('--columns-desktop')) || 4;
      const columnsTablet = parseInt(wrapper.style.getPropertyValue('--columns-tablet')) || 2;
      const columnsMobile = parseInt(wrapper.style.getPropertyValue('--columns-mobile')) || 1;

      if (window.innerWidth >= 1024) return columnsDesktop;
      if (window.innerWidth >= 768) return columnsTablet;
      return columnsMobile;
    }

    // Initialize load more
    initLoadMore();

    // Reinitialize load more when facets are updated (filters applied/cleared)
    document.addEventListener('facets:updated', () => {
      // Small delay to ensure DOM is updated
      requestAnimationFrame(() => {
        initLoadMore();
      });
    });

    // Cleanup ScrollTriggers
    function cleanup() {
      isAnimating = false;
      // Kill all ScrollTriggers associated with this collection
      if (ScrollTrigger) {
        ScrollTrigger.getAll().forEach(trigger => {
          if (wrapper && wrapper.contains(trigger.trigger)) {
            trigger.kill();
          }
        });
      }
    }

    // Cleanup is handled within initCollection - no global listener needed
  }

  // Initialize on page load
  function init() {
    initCollection();
  }

  // Reinitialize after Swup page transitions
  function handleSwupContentReplaced() {
    // Wait for fonts to load before initializing (prevents SplitText warning)
    if (window.waitForFonts) {
      window.waitForFonts(() => {
        initCollection();
      });
    } else {
      // Fallback if waitForFonts not available
      requestAnimationFrame(() => {
        initCollection();
      });
    }
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Listen for Swup content replacement to reinitialize
  if (window.onSwupContentReplaced) {
    window.onSwupContentReplaced('collection-init', handleSwupContentReplaced);
  }
})();
</script>

{% schema %}
{
  "name": "Collection",
  "settings": [
    {
      "type": "checkbox",
      "id": "show_breadcrumbs",
      "label": "Show breadcrumbs",
      "default": false
    },
    {
      "type": "text_alignment",
      "id": "header_alignment",
      "label": "Header alignment",
      "default": "left"
    },
    {
      "type": "checkbox",
      "id": "show_product_count",
      "label": "Show product count",
      "default": true
    },
    {
      "type": "checkbox",
      "id": "show_description",
      "label": "Show collection description",
      "default": true
    },
    {
      "type": "checkbox",
      "id": "enable_description_shuffle",
      "label": "Enable description shuffle effect",
      "default": false,
      "info": "Animate description with text scramble effect on page load"
    },
    {
      "type": "header",
      "content": "Layout"
    },
   {
      "type": "checkbox",
      "id": "full_width",
      "label": "Full width",
      "default": false
    },
    {
      "type": "checkbox",
      "id": "enable_bento_pattern",
      "label": "Enable bento layout",
      "default": false,
      "info": "Display products in a modern bento/metro grid with varying sizes (hero, wide, tall items)"
    },
    {
      "type": "range",
      "id": "columns_desktop",
      "min": 2,
      "max": 5,
      "step": 1,
      "default": 4,
      "label": "Columns on desktop",
      "info": "For bento layout, 4+ columns recommended"
    },
    {
      "type": "range",
      "id": "columns_tablet",
      "min": 1,
      "max": 3,
      "step": 1,
      "default": 2,
      "label": "Columns on tablet"
    },
    {
      "type": "select",
      "id": "columns_mobile",
      "label": "Columns on mobile",
      "options": [
        { "value": "1", "label": "1" },
        { "value": "2", "label": "2" }
      ],
      "default": "1"
    },
    {
      "type": "header",
      "content": "Pagination"
    },
    {
      "type": "select",
      "id": "pagination_type",
      "label": "Pagination type",
      "options": [
        {
          "value": "load_more",
          "label": "Load more"
        },
        {
          "value": "prev_next",
          "label": "Previous / Next"
        }
      ],
      "default": "load_more"
    },
    {
      "type": "range",
      "id": "products_per_page",
      "min": 4,
      "max": 24,
      "step": 1,
      "default": 12,
      "label": "Products per page"
    },
    {
      "type": "header",
      "content": "Filtering and sorting"
    },
    {
      "type": "checkbox",
      "id": "enable_filtering",
      "label": "Enable filtering",
      "default": true,
      "info": "Allow customers to filter products by availability, price, and other options"
    },
    {
      "type": "checkbox",
      "id": "enable_sorting",
      "label": "Enable sorting",
      "default": true,
      "info": "Allow customers to sort products"
    },
    {
      "type": "checkbox",
      "id": "enable_layout_toggle",
      "label": "Enable layout toggle",
      "default": true,
      "info": "Allow customers to switch between grid and list views"
    },
    {
      "type": "color_scheme",
      "id": "color_scheme",
      "label": "Color scheme",
      "default": "scheme-1"
    }
  ],
  "disabled_on": {
    "groups": ["header", "footer"]
  }
  }
{% endschema %}
