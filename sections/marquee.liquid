{%- comment -%}
  Marquee Section - Infinite scrolling text ticker
  Advanced version with scroll direction detection and speed acceleration
{%- endcomment -%}

<div
  class="marquee-section overflow-hidden color-{{ section.settings.color_scheme }}"
  data-marquee-section="{{ section.id }}"
  data-marquee-direction="{{ section.settings.direction }}"
  data-marquee-speed="{{ section.settings.speed }}"
  data-marquee-scroll-aware="{{ section.settings.scroll_aware }}"
  data-marquee-scroll-speed="{{ section.settings.scroll_speed }}"
  data-marquee-pause-on-hover="{{ section.settings.pause_on_hover }}"
  data-marquee-status="normal">
  <div class="marquee-wrapper">
    <div class="marquee-content">
      {% for block in section.blocks %}
        <div class="marquee-item" {{ block.shopify_attributes }}>
          {% case block.type %}
            {% when 'text' %}
              <span class="marquee-text{% if block.settings.outline %} outline{% endif %}">
                {{ block.settings.text }}
              </span>
            {% when 'separator' %}
              {% if block.settings.style == 'dot' %}
                <span class="marquee-separator"></span>
              {% elsif block.settings.style == 'icon' %}
                <i class="marquee-icon ph ph-{{ block.settings.icon }}"></i>
              {% endif %}
          {% endcase %}
        </div>
      {% endfor %}
    </div>
  </div>
</div>

<script>
  (function() {
  const sectionId = '{{ section.id }}';
  const section = document.querySelector(`[data-marquee-section="${sectionId}"]`);
  if (!section || section.dataset.marqueeInitialized) return;
  section.dataset.marqueeInitialized = 'true';

  const wrapper = section.querySelector('.marquee-wrapper');
  const content = section.querySelector('.marquee-content');
  if (!wrapper || !content) return;

  // Configuration from data attributes
  const direction = section.dataset.marqueeDirection === 'right' ? 1 : -1;
  const baseSpeed = parseFloat(section.dataset.marqueeSpeed) || 30;
  const scrollAware = section.dataset.marqueeScrollAware === 'true';
  const scrollSpeedMultiplier = parseFloat(section.dataset.marqueeScrollSpeed) || 2;
  const pauseOnHover = section.dataset.marqueePauseOnHover === 'true';

  let tween = null;
  let isHovered = false;
  // Direction multiplier: -1 = left (content moves left/negative x), 1 = right (content moves right/positive x)
  // Setting "left" means visual movement to left, setting "right" means visual movement to right
  let currentDirection = direction === 1 ? 1 : -1; // right setting = 1, left setting = -1

  function initMarquee() {
    const gsap = window.pieces?.gsap || window.gsap;
    const ScrollTrigger = window.pieces?.ScrollTrigger || window.ScrollTrigger;

    if (!gsap || !ScrollTrigger) {
      requestAnimationFrame(initMarquee);
      return;
    }

    // Duplicate content for seamless loop
    const items = content.querySelectorAll('.marquee-item');
    if (items.length === 0) return;

    // Calculate total width of original content
    let totalWidth = 0;
    items.forEach(item => {
      totalWidth += item.offsetWidth;
    });

    // Add gap to total width calculation
    const style = getComputedStyle(content);
    const gap = parseFloat(style.gap) || 0;
    totalWidth += gap * items.length;

    // Clone items until we have enough for seamless scroll
    const viewportWidth = window.innerWidth;
    const clonesNeeded = Math.ceil((viewportWidth * 3) / totalWidth) + 1;

    for (let i = 0; i < clonesNeeded; i++) {
      items.forEach(item => {
        const clone = item.cloneNode(true);
        clone.setAttribute('aria-hidden', 'true');
        content.appendChild(clone);
      });
    }

    // Recalculate total width after cloning (one set width for looping)
    let oneSetWidth = 0;
    for (let i = 0; i < items.length; i++) {
      oneSetWidth += items[i].offsetWidth + gap;
    }

    // Create wrap function for seamless looping
    const wrapX = gsap.utils.wrap(-oneSetWidth, 0);

    // Set initial position based on direction
    // For right direction (1), start at -oneSetWidth so we can move towards 0 (positive movement)
    // For left direction (-1), start at 0 so we can move towards -oneSetWidth (negative movement)
    const startX = currentDirection === 1 ? -oneSetWidth : 0;
    gsap.set(content, { x: startX });

    // Speed in pixels per second
    const pixelsPerSecond = oneSetWidth / baseSpeed;
    let currentX = startX;

    // Use gsap.ticker for smooth continuous animation
    function animate(time, deltaTime) {
      if (!tween || tween.paused) return;

      // Calculate movement based on direction and delta time
      const movement = (pixelsPerSecond * deltaTime / 1000) * currentDirection;
      currentX += movement;

      // Wrap the position
      currentX = wrapX(currentX);

      gsap.set(content, { x: currentX });
    }

    // Create a simple object to control play/pause state
    tween = {
      paused: false,
      pause: function() { this.paused = true; },
      play: function() { this.paused = false; },
      kill: function() { gsap.ticker.remove(animate); }
    };

    gsap.ticker.add(animate);

    // Scroll-aware direction inversion and acceleration (only if enabled in section settings)
    if (scrollAware) {
      // Store the initial direction for reference
      const initialDirection = currentDirection;
      let lastScrollY = window.scrollY;
      let scrollDelta = 0;
      const scrollThreshold = 50; // Minimum scroll distance to trigger direction change
      let currentScrollState = null; // null = initial, 'down' = scrolling down, 'up' = scrolling up

      // Direction inversion on scroll
      ScrollTrigger.create({
        trigger: section,
        start: 'top bottom',
        end: 'bottom top',
        onUpdate: function(self) {
          if (isHovered || !tween) return;

          // Calculate actual scroll delta
          const currentScrollY = window.scrollY;
          const delta = currentScrollY - lastScrollY;
          lastScrollY = currentScrollY;

          // Ignore tiny movements (Lenis settling, momentum)
          if (Math.abs(delta) < 3) return;

          // Accumulate scroll in same direction, reset if direction changes
          if ((delta > 0 && scrollDelta >= 0) || (delta < 0 && scrollDelta <= 0)) {
            scrollDelta += delta;
          } else {
            // Direction changed, reset delta
            scrollDelta = delta;
          }

          // Only trigger direction change after significant scroll
          if (Math.abs(scrollDelta) < scrollThreshold) return;

          // Determine new scroll state
          const newScrollState = scrollDelta > 0 ? 'down' : 'up';

          // Only change if scroll state actually changed
          if (currentScrollState === newScrollState) return;
          currentScrollState = newScrollState;
          scrollDelta = 0; // Reset after state change

          // Calculate new direction:
          // - Scroll down = NORMAL (same as initial)
          // - Scroll up = INVERTED (opposite of initial)
          let newDirection;
          if (newScrollState === 'down') {
            // Normal: same as initial direction
            newDirection = initialDirection;
            section.dataset.marqueeStatus = 'normal';
          } else {
            // Inverted: flip the initial direction
            newDirection = -initialDirection;
            section.dataset.marqueeStatus = 'inverted';
          }

          // Only change if direction actually changes
          if (currentDirection === newDirection) return;

          currentDirection = newDirection;
        }
      });

      // Scroll acceleration effect using scrub
      // Expand the wrapper and move it with scroll for acceleration illusion
      const scrollAcceleration = scrollSpeedMultiplier * 5; // Convert 1-5 to vw amount

      // Set wrapper styles for scroll effect
      wrapper.style.marginLeft = -scrollAcceleration + 'vw';
      wrapper.style.width = (scrollAcceleration * 2) + 100 + 'vw';

      // Create scrubbed timeline for scroll acceleration
      gsap.timeline({
        scrollTrigger: {
          trigger: section,
          start: 'top bottom',
          end: 'bottom top',
          scrub: 0
        }
      }).fromTo(wrapper,
        { x: (direction === -1 ? scrollAcceleration : -scrollAcceleration) + 'vw' },
        { x: (direction === -1 ? -scrollAcceleration : scrollAcceleration) + 'vw', ease: 'none' }
      );
    }

    // Pause on hover
    if (pauseOnHover) {
      let statusBeforeHover = section.dataset.marqueeStatus || 'normal';

      section.addEventListener('mouseenter', function() {
        statusBeforeHover = section.dataset.marqueeStatus || 'normal';
        isHovered = true;
        section.dataset.marqueeStatus = 'paused';
        tween.pause();
      });

      section.addEventListener('mouseleave', function() {
        isHovered = false;
        section.dataset.marqueeStatus = statusBeforeHover;
        tween.play();
      });
    }

    // IntersectionObserver for play/pause optimization
    let statusBeforeOffscreen = section.dataset.marqueeStatus || 'normal';

    const observer = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          if (!isHovered && tween) {
            tween.play();
            section.dataset.marqueeStatus = statusBeforeOffscreen;
          }
        } else {
          if (tween) {
            statusBeforeOffscreen = section.dataset.marqueeStatus || 'normal';
            tween.pause();
            section.dataset.marqueeStatus = 'paused';
          }
        }
      });
    }, { threshold: 0 });

    observer.observe(section);
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMarquee);
  } else {
    requestAnimationFrame(initMarquee);
  }
  })();
</script>

{% schema %}
  {
    "name": "Marquee",
    "tag": "section",
    "class": "marquee-section-wrapper",
    "settings": [
      {
        "type": "header",
        "content": "Animation"
      },
      {
        "type": "select",
        "id": "direction",
        "options": [
          {
            "value": "left",
            "label": "Left"
          },
          {
            "value": "right",
            "label": "Right"
          }
        ],
        "default": "left",
        "label": "Direction"
      },
      {
        "type": "range",
        "id": "speed",
        "min": 10,
        "max": 60,
        "step": 5,
        "default": 30,
        "unit": "s",
        "label": "Animation speed",
        "info": "Duration for one complete loop"
      },
      {
        "type": "checkbox",
        "id": "scroll_aware",
        "default": true,
        "label": "Scroll-aware movement",
        "info": "Inverts direction and accelerates based on scroll"
      },
      {
        "type": "range",
        "id": "scroll_speed",
        "min": 1,
        "max": 5,
        "step": 1,
        "default": 2,
        "label": "Scroll acceleration",
        "info": "Max speed multiplier while scrolling"
      },
      {
        "type": "checkbox",
        "id": "pause_on_hover",
        "default": true,
        "label": "Pause on hover"
      },
      {
        "type": "header",
        "content": "Colors"
      },
      {
        "type": "color_scheme",
        "id": "color_scheme",
        "label": "Color scheme",
        "default": "scheme-3"
      }
    ],
    "blocks": [
      {
        "type": "text",
        "name": "Text",
        "settings": [
          {
            "type": "text",
            "id": "text",
            "default": "Free Shipping",
            "label": "Text"
          },
          {
            "type": "checkbox",
            "id": "outline",
            "default": false,
            "label": "Outline style"
          }
        ]
      },
      {
        "type": "separator",
        "name": "Separator",
        "settings": [
          {
            "type": "select",
            "id": "style",
            "options": [
              {
                "value": "dot",
                "label": "Dot"
              },
              {
                "value": "icon",
                "label": "Icon"
              }
            ],
            "default": "dot",
            "label": "Style"
          },
          {
            "type": "text",
            "id": "icon",
            "default": "star-four",
            "label": "Icon name",
            "info": "Phosphor icon name (e.g., star-four, asterisk, diamond)"
          }
        ]
      }
    ],
    "presets": [
      {
        "name": "Marquee",
        "category": "Scrolling & animation",
        "blocks": [
          {
            "type": "text",
            "settings": {
              "text": "Free Shipping"
            }
          },
          {
            "type": "separator",
            "settings": {
              "style": "dot"
            }
          },
          {
            "type": "text",
            "settings": {
              "text": "New Arrivals",
              "outline": true
            }
          },
          {
            "type": "separator",
            "settings": {
              "style": "icon",
              "icon": "star-four"
            }
          },
          {
            "type": "text",
            "settings": {
              "text": "Limited Edition"
            }
          },
          {
            "type": "separator",
            "settings": {
              "style": "dot"
            }
          }
        ]
      }
    ],
    "disabled_on": {
      "groups": ["header", "footer"]
    }
    }
{% endschema %}