{%- comment -%}
  Related Products Section - Carousel with GSAP animations
  Uses Shopify Product Recommendations API
{%- endcomment -%}

{%- liquid
  capture container_class
    render 'container-class', full_width: section.settings.full_width
  endcapture
-%}

<style>
  .related-products-{{ section.id }} .skeleton-bg {
    background-color: var(--color-text);
    opacity: 0.1;
  }
  /* Hide scrollbar for native scroll-snap track */
  .related-products-{{ section.id }} .related-products-track::-webkit-scrollbar {
    display: none;
  }
  /* Responsive slide widths using CSS variables from section settings */
  .related-products-{{ section.id }} .related-products-slide {
    --gap: 1rem;
    width: calc((100% - (var(--gap) * (var(--slides-mobile) - 1))) / var(--slides-mobile));
  }
  @media (min-width: 768px) {
    .related-products-{{ section.id }} .related-products-slide {
      --gap: 1.5rem;
      width: calc((100% - (var(--gap) * (var(--slides-tablet) - 1))) / var(--slides-tablet));
    }
  }
  @media (min-width: 1024px) {
    .related-products-{{ section.id }} .related-products-slide {
      width: calc((100% - (var(--gap) * (var(--slides-desktop) - 1))) / var(--slides-desktop));
    }
  }
  /* Title line reveal animation (managed by TweenManager) */
  .tween-split-line:nth-child(2) { margin-left: clamp(0.5rem, 4vw, 2rem); }
</style>

<section
  class="related-products-{{ section.id }} color-{{ section.settings.color_scheme }} section-padding overflow-hidden"
  data-related-products
  data-section-id="{{ section.id }}"
  data-product-id="{{ product.id }}"
  data-url="{{ routes.product_recommendations_url }}?limit={{ section.settings.products_to_show }}"
  data-slides-mobile="{{ section.settings.slides_mobile }}"
  data-slides-tablet="{{ section.settings.slides_tablet }}"
  data-slides-desktop="{{ section.settings.slides_desktop }}"
  style="--slides-mobile: {{ section.settings.slides_mobile }}; --slides-tablet: {{ section.settings.slides_tablet }}; --slides-desktop: {{ section.settings.slides_desktop }};"
>
  <div class="{{ container_class }}">
    {%- comment -%} Header {%- endcomment -%}
    <div class="{% if section.settings.header_alignment == 'center' %}text-center{% elsif section.settings.header_alignment == 'right' %}text-right{% else %}flex items-end justify-between gap-6{% endif %} section-header-spacing">
      <div data-tween-group="related-products-header-{{ section.id }}">
        {% if section.settings.label != blank %}
          <span class="section-label" data-tween data-tween-type="fade-up">
            {{ section.settings.label }}
          </span>
        {% endif %}

        {% if section.settings.title != blank %}
          <h2 class="section-title" data-tween data-tween-type="split-text">
            {{ section.settings.title }}
          </h2>
        {% endif %}
      </div>

      {%- comment -%} Navigation {%- endcomment -%}
      <div class="slider-nav {% if section.settings.header_alignment == 'center' %}justify-center mt-6{% elsif section.settings.header_alignment == 'right' %}justify-end mt-6{% endif %}" data-carousel-nav>
        <button
          type="button"
          class="slider-nav-btn"
          data-carousel-prev
          aria-label="{{ 'accessibility.previous_products' | t }}"
          disabled
        >
          <i class="ph ph-arrow-left"></i>
        </button>
        <button
          type="button"
          class="slider-nav-btn"
          data-carousel-next
          aria-label="{{ 'accessibility.next_products' | t }}"
        >
          <i class="ph ph-arrow-right"></i>
        </button>
      </div>
    </div>

    {%- comment -%} Carousel Container {%- endcomment -%}
    <div class="relative">
      {%- comment -%} Loading State - uses same slide class for consistent sizing {%- endcomment -%}
      <div class="flex gap-4 md:gap-6 overflow-hidden" data-carousel-loading>
        {% for i in (1..section.settings.products_to_show) %}
          <div class="related-products-slide shrink-0 animate-pulse">
            <div class="aspect-3/4 rounded-lg skeleton-bg"></div>
            <div class="h-4 mt-4 rounded skeleton-bg w-3/4"></div>
            <div class="h-3.5 mt-2 rounded skeleton-bg w-2/5"></div>
          </div>
        {% endfor %}
      </div>

      {%- comment -%} Products will be loaded here via JS - Native scroll-snap {%- endcomment -%}
      <div class="related-products-track flex gap-4 md:gap-6 overflow-x-auto items-stretch" data-carousel-track style="display: none; scroll-snap-type: x mandatory; scroll-behavior: smooth; -webkit-overflow-scrolling: touch; scrollbar-width: none; -ms-overflow-style: none;">
        {% if recommendations.performed and recommendations.products_count > 0 %}
          {% for recommendation in recommendations.products %}
            <div class="related-products-slide shrink-0 flex" style="scroll-snap-align: start;">
              {% render 'product-card',
                product: recommendation,
                index: forloop.index0,
                show_quick_add: false,
                lazy_load: true
              %}
            </div>
          {% endfor %}
        {% endif %}
      </div>

      {%- comment -%} Progress Bar {%- endcomment -%}
      {% if section.settings.show_progress_bar %}
        <div class="h-0.5 bg-current/15 rounded-sm overflow-hidden mt-8" data-carousel-progress>
          <div class="h-full w-0 bg-current transition-[width] duration-400 ease-out" data-carousel-progress-bar></div>
        </div>
      {% endif %}
    </div>
  </div>
</section>

<script>
  (function() {
    const section = document.querySelector('[data-related-products][data-section-id="{{ section.id }}"]');
    if (!section) return;

    const productId = section.dataset.productId;
    const baseUrl = section.dataset.url;
    const sectionId = section.dataset.sectionId;

    const track = section.querySelector('[data-carousel-track]');
    const loading = section.querySelector('[data-carousel-loading]');
    const prevBtn = section.querySelector('[data-carousel-prev]');
    const nextBtn = section.querySelector('[data-carousel-next]');
    const progressBar = section.querySelector('[data-carousel-progress-bar]');
    const progressContainer = section.querySelector('[data-carousel-progress]');
    const nav = section.querySelector('[data-carousel-nav]');

    let totalSlides = 0;
    let isAnimating = false;

    // Get slides per view settings from data attributes
    const slidesMobile = parseInt(section.dataset.slidesMobile, 10) || 1;
    const slidesTablet = parseInt(section.dataset.slidesTablet, 10) || 2;
    const slidesDesktop = parseInt(section.dataset.slidesDesktop, 10) || 4;

    // Get slides per view for current breakpoint
    function getSlidesPerView() {
      const width = window.innerWidth;
      if (width >= 1024) return slidesDesktop;
      if (width >= 768) return slidesTablet;
      return slidesMobile;
    }

    // Get max scroll index
    function getMaxIndex() {
      const slidesPerView = getSlidesPerView();
      return Math.max(0, totalSlides - slidesPerView);
    }

    // Get current slide index based on scroll position
    function getCurrentIndex() {
      if (!track.children.length) return 0;
      const slideWidth = track.children[0].offsetWidth;
      const gap = parseFloat(getComputedStyle(track).gap) || 0;
      return Math.round(track.scrollLeft / (slideWidth + gap));
    }

    // Scroll to specific slide
    function scrollToSlide(index) {
      const slides = track.children;
      if (!slides[index] || isAnimating) return;

      isAnimating = true;
      // Pre-update button states and progress bar for target position (instant feedback)
      const maxIndex = getMaxIndex();
      const slidesPerView = getSlidesPerView();
      if (prevBtn) prevBtn.disabled = index <= 0;
      if (nextBtn) nextBtn.disabled = index >= maxIndex;
      if (progressBar) {
        const progress = maxIndex > 0 ? ((index + slidesPerView) / totalSlides) * 100 : 100;
        progressBar.style.width = `${Math.min(100, progress)}%`;
      }

      const slideWidth = slides[0].offsetWidth;
      const gap = parseFloat(getComputedStyle(track).gap) || 0;
      const targetScroll = index * (slideWidth + gap);

      track.scrollTo({ left: targetScroll, behavior: 'smooth' });
    }

    // Update button states and progress bar
    function updateButtonStates(index) {
      const maxIndex = getMaxIndex();
      const slidesPerView = getSlidesPerView();

      if (prevBtn) prevBtn.disabled = index <= 0;
      if (nextBtn) nextBtn.disabled = index >= maxIndex;

      // Update progress bar
      if (progressBar) {
        const progress = maxIndex > 0 ? ((index + slidesPerView) / totalSlides) * 100 : 100;
        progressBar.style.width = `${Math.min(100, progress)}%`;
      }
    }

    // Update nav and progress bar visibility
    function updateNavVisibility() {
      const slidesPerView = getSlidesPerView();
      const shouldHide = totalSlides <= slidesPerView;

      if (nav) {
        if (shouldHide) {
          nav.classList.add('is-hidden');
        } else {
          nav.classList.remove('is-hidden');
        }
      }

      if (progressContainer) {
        progressContainer.style.display = shouldHide ? 'none' : '';
      }

      updateButtonStates(getCurrentIndex());
    }

    function loadRecommendations() {
      const url = `${baseUrl}&product_id=${productId}&section_id=${sectionId}`;

      fetch(url)
        .then(response => response.text())
        .then(html => {
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          const newTrack = doc.querySelector('[data-carousel-track]');

          if (newTrack && newTrack.children.length > 0) {
            track.innerHTML = newTrack.innerHTML;
            totalSlides = track.children.length;

            // Remove tween attributes from dynamically loaded content
            // (they cause opacity: 0 issues when loaded after page init)
            track.querySelectorAll('[data-tween]').forEach(el => {
              el.removeAttribute('data-tween');
              el.removeAttribute('data-tween-type');
              el.style.opacity = '1';
              el.style.transform = 'none';
            });

            loading.style.display = 'none';
            track.style.display = 'flex';

            updateNavVisibility();
            updateButtonStates(0);
          } else {
            // No recommendations, hide the entire section
            section.style.display = 'none';
            // Trigger ScrollTrigger refresh for footer reveal
            const _ScrollTrigger = window.pieces?.ScrollTrigger || window.ScrollTrigger;
            if (_ScrollTrigger) _ScrollTrigger.refresh();
          }
        })
        .catch(error => {
          console.error('Error loading recommendations:', error);
          section.style.display = 'none';
          // Trigger ScrollTrigger refresh for footer reveal
          const _ScrollTrigger = window.pieces?.ScrollTrigger || window.ScrollTrigger;
          if (_ScrollTrigger) _ScrollTrigger.refresh();
        });
    }

    // Navigation buttons
    if (prevBtn) {
      prevBtn.addEventListener('click', () => {
        const current = getCurrentIndex();
        if (current > 0) {
          scrollToSlide(current - 1);
        }
      });
    }

    if (nextBtn) {
      nextBtn.addEventListener('click', () => {
        const current = getCurrentIndex();
        const maxIndex = getMaxIndex();
        if (current < maxIndex) {
          scrollToSlide(current + 1);
        }
      });
    }

    // Sync button states and progress bar with scroll position
    let scrollTimeout;
    track.addEventListener('scroll', () => {
      // Update progress bar and button states immediately during scroll (real-time feedback)
      const currentIndex = getCurrentIndex();
      const maxIndex = getMaxIndex();
      const slidesPerView = getSlidesPerView();
      if (progressBar) {
        const progress = maxIndex > 0 ? ((currentIndex + slidesPerView) / totalSlides) * 100 : 100;
        progressBar.style.width = `${Math.min(100, progress)}%`;
      }
      if (prevBtn) prevBtn.disabled = currentIndex <= 0;
      if (nextBtn) nextBtn.disabled = currentIndex >= maxIndex;

      // Debounce isAnimating reset
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isAnimating = false;
      }, 50);
    }, { passive: true });

    // Update on resize
    window.addEventListener('resize', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(updateNavVisibility, 100);
    });

    // Initialize with Intersection Observer for lazy loading
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          loadRecommendations();
          observer.unobserve(section);
        }
      });
    }, { rootMargin: '200px' });

    observer.observe(section);
  })();
</script>

{% schema %}
{
  "name": "Related Products",
  "tag": "section",
  "class": "related-products-section",
  "settings": [
    {
      "type": "paragraph",
      "content": "Dynamic recommendations are based on the current product. To preview, view this section on a product page."
    },
    {
      "type": "checkbox",
      "id": "full_width",
      "label": "Full width",
      "default": false
    },
    {
      "type": "header",
      "content": "Content"
    },
    {
      "type": "text",
      "id": "label",
      "label": "Label",
      "default": "You may also like"
    },
    {
      "type": "text",
      "id": "title",
      "label": "Title",
      "default": "Related Products"
    },
    {
      "type": "select",
      "id": "header_alignment",
      "label": "Header alignment",
      "default": "left",
      "options": [
        { "value": "left", "label": "Left" },
        { "value": "center", "label": "Center" },
        { "value": "right", "label": "Right" }
      ]
    },
    {
      "type": "header",
      "content": "Layout"
    },
    {
      "type": "range",
      "id": "products_to_show",
      "min": 4,
      "max": 12,
      "step": 1,
      "default": 8,
      "label": "Products to show"
    },
    {
      "type": "select",
      "id": "slides_mobile",
      "default": "1",
      "label": "Slides per view (mobile)",
      "options": [
        { "value": "1", "label": "1" },
        { "value": "2", "label": "2" }
      ]
    },
    {
      "type": "select",
      "id": "slides_tablet",
      "default": "2",
      "label": "Slides per view (tablet)",
      "options": [
        { "value": "1", "label": "1" },
        { "value": "2", "label": "2" },
        { "value": "3", "label": "3" }
      ]
    },
    {
      "type": "select",
      "id": "slides_desktop",
      "default": "4",
      "label": "Slides per view (desktop)",
      "options": [
        { "value": "2", "label": "2" },
        { "value": "3", "label": "3" },
        { "value": "4", "label": "4" },
        { "value": "5", "label": "5" }
      ]
    },
    {
      "type": "checkbox",
      "id": "show_progress_bar",
      "default": true,
      "label": "Show progress bar"
    },
    {
      "type": "header",
      "content": "Colors"
    },
    {
      "type": "color_scheme",
      "id": "color_scheme",
      "label": "Color scheme",
      "default": "scheme-1"
    }
  ],
  "presets": [
    {
      "name": "Related Products",
      "category": "Products"
    }
  ],
  "enabled_on": {
    "templates": ["product"]
  }
}
{% endschema %}
